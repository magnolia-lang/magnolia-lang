#include "E.hpp"
#include <cassert>


namespace tests {
namespace self_contained_codegen {
namespace inputs {
namespace generalTranslationTests {
struct P {
private:
    struct dummy_struct {};
    struct dummy_struct0 {};
    struct dummy_struct1 {};
public:
    typedef ExternalImplementation<dummy_struct>::Y Y;
    typedef ExternalImplementationSomeMoreTypes<dummy_struct, dummy_struct0, dummy_struct1>::AConcreteType AConcreteType;
    typedef ExternalImplementationSomeTypes<dummy_struct>::B X;
    P::Y _mkY();
    void all_statements(const P::X& x_obs, P::X& x_upd, P::X& x_out);
    P::X binary_add(const P::X& lhs, const P::X& rhs);
    P::X call_f_overloaded_on_return_type();
    void helper_assign(P::X& x_out);
    P::X mkX();
    void some_f_overloaded_on_return_type0(P::X& o);
    void some_f_overloaded_on_return_type0(P::Y& o);
    template <typename T>
    inline T some_f_overloaded_on_return_type() {
        T o;
        some_f_overloaded_on_return_type0(o);
        return o;
    };
private:
    ExternalImplementation<X> __ExternalImplementation;
    ExternalImplementationSomeMoreTypes<Y, X, Y> __ExternalImplementationSomeMoreTypes;
    ExternalImplementationSomeTypes<Y> __ExternalImplementationSomeTypes;

};
} // tests
} // self_contained_codegen
} // inputs
} // generalTranslationTests
#include "gen/tests/self-contained-codegen/inputs/generalTranslationTests.hpp"


namespace tests {
namespace self_contained_codegen {
namespace inputs {
namespace generalTranslationTests {
    P::Y P::_mkY() {
        return __ExternalImplementation.mkY();
    };
    void P::all_statements(const P::X& x_obs, P::X& x_upd, P::X& x_out) {
        x_out = x_obs;
        x_out = [=, this]() {
            return P::mkX();
        }();
        P::X x_var_unassigned;
        P::X x_var_assigned = x_obs;
        assert((x_obs) == (x_obs));
        P::helper_assign(x_upd);
        x_out = (x_obs) == (x_obs) ? x_out : x_obs;
        if ((x_obs) == (x_obs))
        {
            ;
        }
        else
        {
            ;
        }
        if ((true) || (false))
        {
            ;
        }
        else
        {
            ;
        }
    };
    P::X P::binary_add(const P::X& lhs, const P::X& rhs) {
        return __ExternalImplementation.binary_add(lhs, rhs);
    };
    P::X P::call_f_overloaded_on_return_type() {
        return P::some_f_overloaded_on_return_type<X>();
    };
    void P::helper_assign(P::X& x_out) {
        x_out = P::mkX();
    };
    P::X P::mkX() {
        return __ExternalImplementation.mkX();
    };
    void P::some_f_overloaded_on_return_type0(P::X& o) {
        o = P::mkX();
    };
    void P::some_f_overloaded_on_return_type0(P::Y& o) {
        o = P::_mkY();
    };
} // tests
} // self_contained_codegen
} // inputs
} // generalTranslationTests
