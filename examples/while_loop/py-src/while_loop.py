from base import int16_utils, int32_utils, while_ops
from multiple_dispatch import overload

if True:
    # TODO: create all the hidden objects
    __int16_utils = int16_utils.int16_utils()
    __int32_utils = int32_utils.int32_utils()
    Int16 = __int16_utils.Int16
    Int32 = __int32_utils.Int32

    @overload(Int32, Int32, return_type=Int32)
    def add(a, b):
        return __int32_utils.add(a, b)

    @overload(Int16, Int16, return_type=Int16)
    def add(a, b):
        return __int16_utils.add(a, b)

    @overload(Int32, Int32, return_type=bool)
    def isLowerThan(state: Int32, ctx: Int32): # TODO: this is a multimethod
        return __int32_utils.isLowerThan(state, ctx)
    
    @overload(Int16, Int16, return_type=bool)
    def isLowerThan(state: Int16, ctx: Int16):
        return __int32_utils.isLowerThan(state, ctx)

    @overload(return_type=Int32)
    def one(): # TODO: this is a multimethod
        return __int32_utils.one()

    @overload(return_type=Int16)
    def one():
        return __int16_utils.one()

    # TODO: increment is a multimethod generated by us. We only write the 32
    #       bits one for the sake of the example.
    #       One other issue is the difference between procedures and functions
    #       in Python. Types such as int can not be mutated.
    #       One way to look at it is that we can functionalize everything (but
    #       it feels a bit clumsy); another is that we can establish a
    #       convention that forces types to implement a "mutate" method, and
    #       therefore not use the default assignment.
    @overload(Int32, Int32, return_type=None)
    def increment(state: Int32, ctx: Int32):
        state.mutate(add(state, one(return_type=Int32)))

    @overload(Int16, Int16, return_type=None)
    def increment(state: Int16, ctx: Int16):
        state.mutate(add(state, one(return_type=Int16)))

    __while_ops  = while_ops.while_ops(Int16, Int16, isLowerThan, increment)
    __while_ops0 = while_ops.while_ops(Int32, Int32, isLowerThan, increment)

    # TODO: define body, cond, etc...

    @overload(Int16, Int16, return_type=None)
    def repeat(state: Int16, ctx: Int16):
        __while_ops.repeat(state, ctx)

    @overload(Int32, Int32, return_type=None)
    def repeat(state: Int32, ctx: Int32):
        __while_ops0.repeat(state, ctx)
