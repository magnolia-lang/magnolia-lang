\documentclass{article}
\author{Marius Kleppe Larn√∏y}

\begin{document}

\title{MoA core Magnolia API}
\maketitle

\noindent Here we outline the core MoA Magnolia API, including padding operations. For now all components are \texttt{implementation} modules, reason being the convenience of producing working code faster. The implementations can easily be enhanced with corresponding \texttt{concept}s when the core structure is in place.

\noindent Rather than going really abstract top-level when designing the API, this specification will be developed more with a concrete implementation in mind.

\noindent The core API will be built upon a small set of external operations for accessing and modifying arrays.

\section{External API}
\begin{itemize}
    \item A struct \texttt{Array} for representing an Array. Stores the elements of the array and its shape.
    \item A struct \texttt{PaddedArray} inheriting \texttt{Array}. In addition to storing the contents, \texttt{PaddedArray} stores both the unpadded and the padded shape

    \item MoA concepts of shape and index is represented by their own typedefs, aliasing  \texttt{std::vector<size\_t>}

    \item Getters/setters with direct array access
    \item Utility functions, like wrappers/unwrappers, (safe) conversion between types
    \item Constructors for arrays, shapes, indices
    \item IO, (pretty)printing, for debugging
    \item templates for looping
    \item structs for Element types (e.g. Int32, Float64)
\end{itemize}

\section{Core concepts/signatures/implementations}

\subsection{\texttt{external implementation ExtOps}}
\noindent The Magnolia side of the external C++ API.

\noindent \textbf{Types:}
\begin{itemize}
    \item Array: unpadded array type
    \item PaddedArray: padded array type
    \item Element (required): Generic element type (assumed to be either an integer type or a floating point type)
    \item Index: Index type
    \item UInt32 (might change): unsigned int type
    \item Shape: the shape type
\end{itemize}
\noindent \textbf{Getters/setters}
\begin{itemize}
    \item \texttt{function get(a: Array, i: Index): Array}
    \item \texttt{procedure set(upd a: Array, obs i: Index, obs e: Element}
\end{itemize}
\noindent \textbf{Unary operations}
\begin{itemize}
    \item \texttt{function dim(a: Array): UInt32}
    \item \texttt{function shape(a: Array): Shape}
    \item \texttt{function total(a: Array): UInt32}
    \item \texttt{function total(s: Shape): UInt32}

\end{itemize}
\noindent \textbf{Various util, array creation, and IO functions}
\subsection{\texttt{implementation Concatenation}}
\noindent Defines catenation on both 1-dim arrays (vectors) and n-dim arrays
\begin{itemize}
    \item \texttt{funcion cat\_vec(vec1:Array, vec2:Array):Array guard dim(vec1) == one() \&\& dim(vec2) == one();}
    \item \texttt{function cat(a1: Array, a2: Array):Array guard drop(one(), shape(a1)) == drop(one(), shape(a2));  }
\end{itemize}
\subsection{\texttt{implementation Padding}}
\noindent Defines operations for circular padding on n-dim arrays
\begin{itemize}
    \item \texttt{function circular\_padr(a: Array, ix: UInt32):PaddedArray}
    \item \texttt{function circular\_padl(a: Array, ix: UInt32):PaddedArray}
    \item \textbf{TODO: finish}
\end{itemize}

\subsection{Implementations for more required operations...}
\subsection{\texttt{concept DNF}}
\noindent DNF transformation rules
\subsection{\texttt{concept ONF}}
\noindent Transforming DNF expressions with specific hardware in mind

\section{General notes, thoughts}

\begin{itemize}
    \item Question: overload functions like total on argument type, or define separate functions for different types. E.g. total of a shape neccessary, or just design shape signature with a function that yields the total
    \item Question: specify Util concepts like Int and abstract structures like Semigroup/Monoid. Not part of core moa, but useful
    \item Question: Would it be any benefit to further split up the concepts? e.g. some functions in one concept, padding separated maybe? not sure
    \item Follow-up: Might be best to define operations closer to their intended arguments. The upside to doing it like this is that we keep the signatures lean and clean, and dont have to import redundant signatures for defining operations. Also avoid circular dependencies
    \item Follow-up2: separate DNF and ONF level operations?
    \item some sort of Map concept? more of a underlying concept, how does the operations actually apply to arrays
    \item Note: Separating the types, while bringing some much needed distinctions between elements, brings with it its own set of issues. Neccessarily it leads to many of the functions requiring overloading, bringing redundancy into the code. Might need some design rethinking to avoid it, or maybe it is a neccessary evil.
    \item Finding it a bit hard to distinguish between which functions are staying in C++ and those that have to be implemented in Magnolia. Why even leave implementation to Mg when it can be done in Cpp
    \item \begin{itemize}
        \item \textbf{Benjamin:} For example, we can not apply rewrite rules on backend code. For axiom-based rewriting, we need to write in Magnolia. Also, our language is more restricted, which allows for different kinds of transformations that would not be possible in C++.
    \end{itemize}
    \item Only template types have keyword required? Makes sense as other types are provided
    \item \begin{itemize}
        \item \textbf{Benjamin:} Required = this external block is well-defined if this type is provided. Not required (in external blocks) = this external block, once well-defined, provides you with this type
    \end{itemize}
    \item Design choice, limit C++ implemented functions to basic access, define the rest via moa in Magnolia
    \item Loops in Magnolia
\end{itemize}

\end{document}