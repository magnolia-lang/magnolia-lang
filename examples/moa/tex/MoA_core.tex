\documentclass{article}
\author{Marius Kleppe LarnÃ¸y}

\begin{document}


\title{MoA core Magnolia API}
\maketitle

\noindent Here we outline the core MoA Magnolia API, including padding operations. For now all modules are \texttt{signature} modules, but we will introduce axioms when the core structure is in place.

\noindent Rather than going really abstract top-level when designing the API, this specification will be developed more with a concrete implementation in mind.

\noindent The core API will be built upon a small set of external operations for accessing and modifying arrays.

\section{External API (C++ for now)}
\begin{itemize}
    \item A stuct \texttt{Array} for representing an Array. Stores the elements of the array and its shape.
    \item \texttt{function get(a: Array, i: Index): Array}
    \item \texttt{procedure set(a: Array, i: Index, e: Element)}
\end{itemize}

\section{Core concepts/signatures}

\subsection{\texttt{signature/concept Array}}
\noindent The generic Array signature. Contains the basic types we need, and the core functions.

\noindent \textbf{Types:}
\begin{itemize}
    \item A: generic (A)rray type
    \item E: generic (E)lement type
    \item I: generic (I)ndex type
    \item Int: some form of integer
    \item Shape: type to represent the collection of an arrays dimensional lengths
\end{itemize}

\noindent \textbf{Unary Operations}
\begin{itemize}
    \item \texttt{dim(a:A):Int}
    \item \texttt{shape(a:A):Shape}
    \item \texttt{total(a:A):Int}
    \item \texttt{total(i:I):Int}
    \item \texttt{total(s:Shape):Int}
\end{itemize}

\noindent \textbf{Binary Operations}
\begin{itemize}
    \item \texttt{cat: Monoid[M => A, op => cat, id => empty]}
    \item \texttt{psi(i:I,a:A):A guard partialIndex(i,a)}
    \item \texttt{psi(i:I,a:A):E guard totalIndex(i,a)}
    \item \texttt{psi(i:I,s:Shape):Int guard total(i)<total(s)}
    \item \texttt{take(i:I,a:A):A guard validIndex(i,a)}
    \item \texttt{drop(i:I,a:A):A guard validIndex(i,a)}
\end{itemize}

\noindent \textbf{Transformations}
\begin{itemize}
    \item \texttt{reverse(a:A):A}
    \item \texttt{rotate(ax:Int,a:A):A guard ax < total(shape(a))}
    \item \texttt{transpose(a:A):A}
\end{itemize}

\noindent \textbf{ONF operations}
\begin{itemize}
    \item \texttt{reshape(s:Shape,a:MultiArray):MultiArray \\ guard total(s)==total(shape(a))}
    \item \texttt{gamma(i:I,s:Shape):I \\ guard totalIndex(i,shapeToArray(s));}
\end{itemize}


\noindent \textbf{Arithmetic operations (map)}
\begin{itemize}
    \item \texttt{BMap[A => A, E => E, bop => \_+\_, bopmap => \_+\_]}
    \item \texttt{BMap[A => A, E => E, bop => \_*\_, bopmap => \_*\_]}
\end{itemize}
\subsection{\texttt{concept Padding}}
\noindent \textbf{TODO}
\subsection{\texttt{concept MoA}}
\noindent Here we import the generic Array concept, and can define separate array types. This also allows us to define more operations requiring finer typing.

\noindent \textbf{Imports/renamings}
\begin{itemize}
    \item \texttt{Array[A => LinearArray, I => LinearIndex]}
    \item \texttt{Array[A => MultiArray, I => MultiIndex]}
\end{itemize}

\noindent \textbf{Operations}
\begin{itemize}
    \item \texttt{iota(i:Int):LinearArray}
    \item \texttt{ravel(a:MultiArray):LinearArray}
\end{itemize}

\section{Util?}
\begin{itemize}
    \item \texttt{concept Semigroup}
    \item \texttt{concept Monoid}
    \item \texttt{concept Int}
    \item \texttt{concept BMap}
    \item \texttt{concept UtilFunctions}
    \begin{itemize}
        \item \texttt{function shapeToArray(s:Shape):A}
        \item \texttt{validIndex(i:I,a:A)}
        \item \texttt{partialIndex(i:I,a:A)} (i.e. \texttt{total(i) < total(shape(a))})
        \item \texttt{totalIndex(i:I,a:A)} (i.e. \texttt{total(i) == total(shape(a))}
    \end{itemize}
\end{itemize}

\section{General notes, thoughts}

\begin{itemize}
    \item Question: overload functions like total on argument type, or define separate functions for different types. E.g. total of a shape neccessary, or just design shape signature with a function that yields the total
    \item Question: specify Util concepts like Int and abstract structures like Semigroup/Monoid. Not part of core moa, but useful
    \item Question: Would it be any benefit to further split up the concepts? e.g. some functions in one concept, padding separated maybe? not sure
    \item Follow-up: Might be best to define operations closer to their intended arguments. The upside to doing it like this is that we keep the signatures lean and clean, and dont have to import redundant signatures for defining operations. Also avoid circular dependencies
    \item Follow-up2: separate DNF and ONF level operations?
    \item some sort of Map concept? more of a underlying concept, how does the operations actually apply to arrays
    \item Note: Separating the types, while bringing some much needed distinctions between elements, brings with it its own set of issues. Neccessarily it leads to many of the functions requiring overloading, bringing redundancy into the code. Might need some design rethinking to avoid it, or maybe it is a neccessary evil.
    \item Finding it a bit hard to distinguish between which functions are staying in C++ and those that have to be implemented in Magnolia. Why even leave implementation to Mg when it can be done in Cpp
    \item \begin{itemize}
        \item \textbf{Benjamin:} For example, we can not apply rewrite rules on backend code. For axiom-based rewriting, we need to write in Magnolia. Also, our language is more restricted, which allows for different kinds of transformations that would not be possible in C++.
    \end{itemize}
    \item Only template types have keyword required? Makes sense as other types are provided
    \item \begin{itemize}
        \item \textbf{Benjamin:} Required = this external block is well-defined if this type is provided. Not required (in external blocks) = this external block, once well-defined, provides you with this type
    \end{itemize}
    \item Design choice, limit C++ implemented functions to basic access, define the rest via moa in Magnolia
    \item Loops in Magnolia
\end{itemize}

\end{document}